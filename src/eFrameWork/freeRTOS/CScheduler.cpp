////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FILE NAME:     $Source:$
//                $Date:$
//                $Revision:$
//
// AUTHOR:        Jean-Sebastien Stoezel (js.stoezel@gmail.com)
//
// HISTORY:       $Log:$
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INCLUDE
#include "CScheduler.hpp"
#include "CLog.hpp"
#include "CSubsystem.hpp"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MACROS

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// STATIC VARIABLES
CScheduler::sEntry_t *     CScheduler::mp_EntryList    = 0;
#ifdef FREERTOS
uint32_t                   CScheduler::m_SystemClock   = configTICK_RATE_HZ;
#else
#endif
uint32_t                   CScheduler::m_Tick          = 0;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32_t CScheduler::NumEntriesGet(void)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
   uint32_t result = 0;
   
   LOG_TRACE("CScheduler::NumEntriesGet");
   
   CScheduler::sEntry_t *   p_Entry    = mp_EntryList;
   
   while(0 != p_Entry)
   {
      LOG_DEBUG("CScheduler::NumEntriesGet entry address=%08X", p_Entry);
      p_Entry = p_Entry->p_Next;
	  result++;
   } // while
   
   LOG_INFO("CScheduler::NumEntriesGet = %u", result);
   
   return result;
} // CScheduler::NumEntriesGet
	  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CScheduler::sEntry_t * CScheduler::EntryGet(
   const uint32_t	id // in, entry index
   )
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
   CScheduler::sEntry_t *   p_Result    = mp_EntryList;
   uint32_t                 cnt         = 0;
   
   LOG_TRACE("CScheduler::Get");
   
   while(cnt < id &&
          0 != p_Result
         )
   {
      LOG_DEBUG("CScheduler::Get id=%u cnt=%u", id, cnt);
      cnt++;
      p_Result = p_Result->p_Next;
   } // while
   
   return p_Result;
} // CScheduler::EntryGet

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int32_t CScheduler::Register(
   const uint32_t     rate, // in
   sEntry_t &         entry // in/out
   )
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
   int32_t      result       = -1;
   sEntry_t *   p_Entry	   = 0;

   LOG_TRACE("CScheduler::Register");
   
   LOG_DEBUG("CScheduler::Register message queue address=%08X", entry.p_ActivationQueue);

   // Insert the new trigger
   if(rate > 0)
   {
      entry.clkDivider = m_SystemClock / rate;
      
      if(0 != entry.clkDivider)
      {
         if(0 == mp_EntryList)
         {
            LOG_DEBUG("CScheduler::Register first entry in list");
            mp_EntryList              = &entry;
            mp_EntryList->p_Next     = 0;
         }
         else
         {
            p_Entry = mp_EntryList;
   
            while(0 != p_Entry->p_Next)
            {
               LOG_DEBUG("CScheduler::Register skipping");
               p_Entry = p_Entry->p_Next;
            }
   
            LOG_DEBUG("CScheduler::Register inserting at end");
            p_Entry->p_Next   = &entry;
            entry.p_Next      = 0;
         }

         LOG_INFO("CScheduler::Register clkDivider=%u", entry.clkDivider);
         result = 0;
      }
      else
      {
         LOG_WARNING("CScheduler::Register clkDivider is 0, m_SystemClock=%u rate=%u", m_SystemClock, rate);
      }
   }
   else
   {
      LOG_WARNING("CScheduler::Register rate is 0");
   }

   return result;
} // CScheduler::Register



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CScheduler::Scheduler(
   const uint32_t tick  // in
   )
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
   CScheduler::sEntry_t *           p_Entry           = mp_EntryList;
   #ifdef FREERTOS
   signed portBASE_TYPE             xHigherPriorityTaskWoken;
   #else
   #endif
   //const CSubsystem::sActivation_t  activationPacket  = {CSubsystem::ACTIVATION_TYPE_SCHEDULER};
   CSubsystem::sActivation_t        activationPacket;
   
   #if 0
   04082010 jstoezel: just too much logging
   LOG_TRACE("CScheduler::Scheduler");
   #endif

   m_Tick = tick;

   while(0 != p_Entry)
   {
      #if 0
      04082010 jstoezel: just too much logging
      LOG_DEBUG("CScheduler::Scheduler next entry %u", p_Entry->clkDivider);
      #endif
	  if( 0 != p_Entry->clkDivider &&
          0 == (m_Tick % p_Entry->clkDivider)
          )
      {
         activationPacket.type            = CSubsystem::ACTIVATION_TYPE_SCHEDULER;
         activationPacket.p_Cmd           = CSubsystem::CommandGet();
         if(0 != activationPacket.p_Cmd)
         {
            activationPacket.p_Cmd->id       = 0;
            activationPacket.p_Cmd->dataLen  = 0;
            // Activating
            #if 0
            //04082010 jstoezel: just too much logging
            LOG_TRACE("CScheduler::Scheduler activating");
            LOG_DEBUG("CScheduler::Scheduler activating %u", activationPacket.type);
            LOG_DEBUG("CScheduler::Scheduler message queue address=%08X", p_Entry->p_ActivationQueue);
            #endif
            #ifdef FREERTOS
            xQueueSendFromISR(*(p_Entry->p_ActivationQueue), &activationPacket, &xHigherPriorityTaskWoken);
            #else
            #endif
         }
         else
         {
            LOG_WARNING("CScheduler::Scheduler could not get command");
         }
      }
      else
      {
         // Skipping
      }

      p_Entry = p_Entry->p_Next;
   } // while
} // CScheduler::Scheduler

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32_t CScheduler::TickGet(void)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
   LOG_TRACE("CScheduler::TickGet");
   return m_Tick;
} // CScheduler::TickGet

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32_t CScheduler::TickGet(
   const CScheduler::sEntry_t &  entry   // in
   )
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
{
   LOG_TRACE("CScheduler::TickGet");
   return ((m_Tick / entry.clkDivider) % (m_SystemClock / entry.clkDivider));
} // CScheduler::TickGet

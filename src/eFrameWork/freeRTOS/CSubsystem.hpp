#ifndef csubsystem_included
#define csubsystem_included


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// FILE NAME:     $Source:$
//                $Date:$
//                $Revision:$
//
// AUTHOR:        Jean-Sebastien Stoezel (js.stoezel@gmail.com)
//
// DESCRIPTION:   The CSubsystem class offers a basic framework for any subsystem to be implemented. Basic services
//                include subsystem initialization, thread interfacing, and IPC handling.
//
// HISTORY:       $Log:$
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <stdint.h>

#include "eframework_config.hpp"

#ifdef FREERTOS
#include "FreeRTOS.h"
#include "semphr.h"
#include "task.h"
#include "queue.h"
#else
#endif

#include "CScheduler.hpp"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CSubsystem
{
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   // TYPES
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   public:
   
      // What activated the subsystem
      typedef enum
      {
         ACTIVATION_TYPE_CMD,         // Command received activation
         ACTIVATION_TYPE_SCHEDULER,   // Periodic activation
         ACTIVATION_TYPE_TIMEOUT,     // No command and no periodic activation received
         ACTIVATION_TYPE_NUM          // Number of activation types
      } eActivationType_t;
      
      // Activation package
      typedef struct
      {
         uint32_t    id;                                 // Command identifier
         bool		   inUse;                              // True if the command is being used
         uint32_t    dataLen;                            // Length of the data field
         uint8_t     data[SUBSYSTEM_MAX_MESSAGE_SIZE];   // Command data field
      } sCommand_t;
      
      // Activation package
      typedef struct
      {
         eActivationType_t	   type;    // Command type
         sCommand_t *         p_Cmd;   // Pointer to command in pool
      } sActivation_t;
      
   protected:  
   private:

   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   // METHODS
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   public:

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          CommandGet
      // DESCRIPTION:   Get a command from the pool
      // RETURN VALUE:  Return a pointer to the command on success, 0 otherwise.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      static CSubsystem::sCommand_t * CommandGet(void);
      
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          Get
      // DESCRIPTION:   Return a pointer to the subsystem identified by name.
      // RETURN VALUE:  pointer to subsystem on success, 0 on error.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      static CSubsystem *  Get(
         char const * const   p_Name   // in, name of the subsystem to get
      );

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          NumGet
      // DESCRIPTION:   Return the number of subsystems currently instantiated.
      // RETURN VALUE:  Return the number of subsystems currently instantiated.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      static uint32_t  NumGet(void);

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          ResetAll
      // DESCRIPTION:   Clear the subsystem list.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      static void ResetAll(void);

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          Startup
      // DESCRIPTION:   Initialize all the subsystems that have been instantiated and release the multitasking system.
      // RETURN VALUE:  0 on success, -1 on error.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      static int32_t Startup(void);

   protected:

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          CSubsystem()
      // DESCRIPTION:   Default constructor.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      CSubsystem();

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          ~CSubsystem()
      // DESCRIPTION:   Default destructor.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      virtual ~CSubsystem();
      
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          ClockGet
      // DESCRIPTION:   Get the current system clock.
      // RETURN VALUE:  System clock.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      uint32_t ClockGet(void);
      
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          CommandHandler
      // DESCRIPTION:   
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      virtual void CommandHandler(void);
	  
	  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          CommandRelease
      // DESCRIPTION:   Release the specified command.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      void CommandRelease(
	     CSubsystem::sCommand_t * const p_Cmd // in, command to release.
	  );
      
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          CommandSend
      // DESCRIPTION:   Send the specified command.
      // RETURN VALUE:  0 on success, - 1 on error.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      int32_t CommandSend(
         CSubsystem const * const               p_Subsystem,   // in, subsystem to send the command to
         CSubsystem::sCommand_t const * const   p_Cmd          // in, command to be sent
         );

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          Get
      // DESCRIPTION:   Return a pointer to the subsystem identified by index.
      // RETURN VALUE:  pointer to subsystem on success, 0 on error.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      static CSubsystem * Get(
         const uint32_t	id // in, subsystem index
         );

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          Init
      // DESCRIPTION:   Initialize the subsystem. Register with the scheduler, and create a thread.
      // RETURN VALUE:  0 on success, -1 on error.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      virtual int32_t Init(void);

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          IsCritical
      // DESCRIPTION:   Check whther the subsystem is critical for execution or not.
      // RETURN VALUE:  true if the subsystem is critical, false otherwise.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      bool IsCritical(void);
      
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          PeriodicHandler
      // DESCRIPTION:   Handles the periodic activation of subsystem.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      virtual void PeriodicHandler(void);

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          Task
      // DESCRIPTION:   Run the subsystem in a multitasking environment.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      virtual void Task(void);

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          TaskWrapper
      // DESCRIPTION:   Provides a static entry point for the subsystem's task.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      static void TaskWrapper(
         void * p_This  // in, reference to this instance
         );

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          TickGet
      // DESCRIPTION:   Return the current tick for the thread.
      // RETURN VALUE:  Tick value, between 0 and (m_Rate - 1).
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      uint32_t TickGet(void) const;
      
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          TimeoutHandler
      // DESCRIPTION:   Handles when a timeout occurs while waiting for activation.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      virtual void TimeoutHandler(void);

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          UnInit
      // DESCRIPTION:   UnInitialize the subsystem.
      // RETURN VALUE:  None
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      virtual void UnInit(void);
      
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          WaitForActivation
      // DESCRIPTION:   Wait for the subsystem to be activated.
      // RETURN VALUE:  None
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      void WaitForActivation(
         const uint32_t timeout   // in, timeout (in ms) after which the function returns.
      );

   private:

      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // NAME:          Add
      // DESCRIPTION:   Add the current instance to the subsystem list.
      // RETURN VALUE:  None.
      //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      void Add(void);

   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   // VARIABLES
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   public:
#ifdef FREERTOS
      xTaskHandle                m_TaskHandle;
      xQueueHandle               m_ActivationQueue;   // Activation queue
#else
#endif
      char const *               mp_Name;             // Name of the subsystem
      uint32_t                   m_StackSize;         // Size of the thread stack, in 32bit words.
   
   protected:
      bool                       m_IsCritical;        // Set to true if the subsystem is required to run the system.
      uint32_t                   m_Priority;          // Priority of the thread.
      uint32_t                   m_Rate;              // Number of periodic activation per second.
      bool                       m_RunTask;           // Set to false to stop the thread.
      uint32_t                   m_ActivationTimeout;
      uint32_t                   m_MaxActivationPackets;
      sActivation_t              m_ActivationPacket;  // Activation packet

   private:
      
      
      CScheduler::sEntry_t       m_SchedulerEntry;
      CSubsystem *               mp_NextSubsystem;    // Next susbsystem in the chained list.
      static CSubsystem *       mp_SubsystemList;    // Chained list of subsystem instantiated.
	  static sCommand_t		      m_CmdPool[];
}; // class CSubsystem
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif // csubsystem_included
